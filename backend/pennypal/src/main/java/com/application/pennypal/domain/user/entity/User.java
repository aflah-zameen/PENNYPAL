package com.application.pennypal.domain.user.entity;

import com.application.pennypal.domain.shared.exception.DomainErrorCode;
import com.application.pennypal.domain.user.exception.business.InvalidUserStateTransitionDomainException;
import com.application.pennypal.domain.user.exception.business.MinimumUserRoleRequiredDomainException;
import com.application.pennypal.domain.user.exception.business.UserNotVerifiedForActivationDomainException;
import com.application.pennypal.domain.user.exception.business.UserRoleNotFoundDomainException;
import com.application.pennypal.domain.user.validator.*;
import com.application.pennypal.domain.user.valueObject.Roles;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;

public class User{

    private final String userId;
    private String name;
    private String email;
    private String password;
    private String phone;
    private Set<Roles> roles;
    private boolean verified;
    private boolean active;
    private boolean isSuspended;
    private final LocalDateTime createdAt;
    private final LocalDateTime updatedAt;
    private String profileURL;

    // Private constructor to enforce domain rules
    private User(String userId, String name, String email, String password, String phone,
                 Set<Roles> roles, boolean active, boolean verified,boolean isSuspended,
                 LocalDateTime createdAt, LocalDateTime updatedAt, String profileURL) {

        validate(name, email, password, phone, roles,profileURL);

        this.userId = userId;
        this.name = name;
        this.email = email;
        this.password = password;
        this.phone = phone;
        this.roles = Set.copyOf(roles);
        this.active = active;
        this.verified = verified;
        this.isSuspended = isSuspended;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.profileURL = profileURL;
    }

    // Factory method to create a new user
    public static User create(String name, String email, String encodedPassword,
                              String phone, Set<Roles> roles, String profileURL) {
        String userId = "USR_"+UUID.randomUUID().toString();
        return new User(
                userId, ///  id is generated by JPA
                name,
                email,
                encodedPassword,
                phone,
                roles,
                false,
                false,
                false,
                null, /// createdAt set by JPA
                null,          /// updatedAt set by JPA
                profileURL
        );
    }

    // Factory method to reconstruct from persistence (e.g. database)
    public static User reconstruct(String userId, String name, String email, String password,
                                   String phone, Set<Roles> roles, boolean active,
                                   boolean verified,boolean isSuspended, LocalDateTime createdAt, LocalDateTime updatedAt,
                                   String profileURL) {

        return new User(
                userId, name, email, password, phone,
                roles, active, verified,isSuspended, createdAt, updatedAt, profileURL
        );
    }

    // Domain validation logic
    private void validate(String name, String email, String password,
                          String phone, Set<Roles> roles,String profileURL) {

        NameValidator.validate(name);
        EncodedPasswordValidator.validate(password);
        EmailValidator.validate(email);
        RoleValidator.validate(roles);
        PhoneValidator.validate(phone);
        URLValidator.validate(profileURL);
    }

    // Business behavior
    public User activate() {
        if (active) throw new InvalidUserStateTransitionDomainException("User is already active", DomainErrorCode.USER_ALREADY_ACTIVE);
        if (!verified) throw new UserNotVerifiedForActivationDomainException("User must be verified to activate");

        this.active = true;
        return this;
    }

    public User deactivate() {
        if (!active) throw new InvalidUserStateTransitionDomainException("User is already inactive",DomainErrorCode.USER_ALREADY_INACTIVE);

        this.active = false;
        return this;
    }

    public User verify() {
        if (verified) throw new InvalidUserStateTransitionDomainException("User is already verified", DomainErrorCode.USER_ALREADY_VERIFIED);

        this.verified = true;
        this.active = true;
        return this;
    }

    public User changeName(String newName){
        NameValidator.validate(newName);
        this.name = name;
        return this;
    }

    public User changePassword(String newPassword) {
        EncodedPasswordValidator.validate(newPassword);
        this.password = newPassword;
        return this;
    }

    public User changeEmail(String newEmail) {
        EmailValidator.validate(newEmail);
        this.email = newEmail;
        return this;
    }

    public User changeProfileURL(String profileURL){
       URLValidator.validate(profileURL);
       this.profileURL = profileURL;
       return this;
    }

    public User changePhone(String newPhone) {
        PhoneValidator.validate(newPhone);

        this.phone = newPhone;
        return this;
    }

    public User addRole(Roles role) {
        Set<Roles> updated = new HashSet<>(roles);
        updated.add(role);
        this.roles = updated;
        return this;
    }

    public User removeRole(Roles role) {
        if (roles.size() <= 1)
            throw new MinimumUserRoleRequiredDomainException("User must have at least one role");

        Set<Roles> updated = new HashSet<>(roles);
        if (!updated.remove(role))
            throw new UserRoleNotFoundDomainException("Role not found: " + role);
        this.roles = updated;
        return this;
    }

    public User markSuspended(){
        this.isSuspended = true;
        return this;
    }

    public User releaseSuspension(){
        this.isSuspended = false;
        return this;
    }


    // Getters
    public String getUserId() { return userId; }
    public String getName() { return name; }
    public String getEmail() { return email; }
    public String getPassword() { return password; }
    public String getPhone() { return phone; }
    public Set<Roles> getRoles() { return Set.copyOf(roles); }
    public boolean isVerified() { return verified; }
    public boolean isSuspended() { return  isSuspended;}
    public boolean isActive() { return active; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public Optional<LocalDateTime> getUpdatedAt() { return Optional.ofNullable(updatedAt); }
    public Optional<String> getProfileURL() { return Optional.ofNullable(profileURL); }

    // Business rule checkers
    public boolean hasRole(Roles role) {
        return roles.contains(role);
    }

    public boolean isAdmin() {
        return roles.contains(Roles.ADMIN);
    }

    public boolean isNormalUser() {
        return roles.contains(Roles.USER);
    }
}
